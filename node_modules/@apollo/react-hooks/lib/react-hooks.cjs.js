'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var reactCommon = require('@apollo/react-common');
var tslib = require('tslib');
var React = require('react');
var React__default = _interopDefault(React);
var apolloClient = require('apollo-client');
var tsInvariant = require('ts-invariant');
require('fast-json-stable-stringify');

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function isEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
    }
    if (a != null &&
        typeof a === 'object' &&
        b != null &&
        typeof b === 'object') {
        for (var key in a) {
            if (Object.prototype.hasOwnProperty.call(a, key)) {
                if (!Object.prototype.hasOwnProperty.call(b, key)) {
                    return false;
                }
                if (!isEqual(a[key], b[key])) {
                    return false;
                }
            }
        }
        for (var key in b) {
            if (Object.prototype.hasOwnProperty.call(b, key) &&
                !Object.prototype.hasOwnProperty.call(a, key)) {
                return false;
            }
        }
        return true;
    }
    return false;
}

var OperationData = (function () {
    function OperationData(options, context) {
        this._isMounted = true;
        this._options = {};
        this._previousOptions = {};
        this._context = {};
        this._options = options || {};
        this._context = context || {};
    }
    Object.defineProperty(OperationData.prototype, "isMounted", {
        get: function () {
            return this._isMounted;
        },
        set: function (mounted) {
            this._isMounted = mounted;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OperationData.prototype, "options", {
        get: function () {
            return this._options;
        },
        set: function (newOptions) {
            if (!isEqual(this.options, newOptions)) {
                this.previousOptions = this.options;
            }
            this._options = newOptions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OperationData.prototype, "previousOptions", {
        get: function () {
            return this._previousOptions;
        },
        set: function (newOptions) {
            this._previousOptions = newOptions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OperationData.prototype, "context", {
        get: function () {
            return this._context;
        },
        set: function (newContext) {
            this._context = newContext;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OperationData.prototype, "client", {
        get: function () {
            return this._client;
        },
        set: function (newClient) {
            this._client = newClient;
        },
        enumerable: true,
        configurable: true
    });
    OperationData.prototype.unmount = function () {
        this.isMounted = false;
    };
    OperationData.prototype.refreshClient = function () {
        var client = (this.options && this.options.client) ||
            (this.context && this.context.client);
        process.env.NODE_ENV === "production" ? tsInvariant.invariant(!!client) : tsInvariant.invariant(!!client, 'Could not find "client" in the context or passed in as an option. ' +
            'Wrap the root component in an <ApolloProvider>, or pass an ' +
            'ApolloClient instance in via options.');
        var isNew = false;
        if (client !== this.client) {
            isNew = true;
            this.client = client;
            this.cleanup();
        }
        return {
            client: this.client,
            isNew: isNew
        };
    };
    OperationData.prototype.verifyDocumentType = function (document, type) {
        var operation = reactCommon.parser(document);
        var requiredOperationName = reactCommon.operationName(type);
        var usedOperationName = reactCommon.operationName(operation.type);
        process.env.NODE_ENV === "production" ? tsInvariant.invariant(operation.type === type) : tsInvariant.invariant(operation.type === type, "Running a " + requiredOperationName + " requires a graphql " +
            (requiredOperationName + ", but a " + usedOperationName + " was used instead."));
    };
    return OperationData;
}());

var QueryData = (function (_super) {
    tslib.__extends(QueryData, _super);
    function QueryData(_a) {
        var options = _a.options, context = _a.context, forceUpdate = _a.forceUpdate;
        var _this = _super.call(this, options, context) || this;
        _this.previousData = {};
        _this.currentObservable = {};
        _this.forceUpdate = forceUpdate;
        return _this;
    }
    QueryData.prototype.execute = function () {
        var _this = this;
        this.refreshClient();
        var _a = this.options, skip = _a.skip, query = _a.query;
        if (skip || query !== this.previousData.query) {
            this.removeQuerySubscription();
            this.previousData.query = query;
        }
        this.updateObservableQuery();
        if (!skip) {
            this.startQuerySubscription();
        }
        var finish = function () { return _this.getQueryResult(); };
        if (this.context && this.context.renderPromises) {
            var result = this.context.renderPromises.addQueryPromise(this, finish);
            return result || { loading: true, networkStatus: apolloClient.NetworkStatus.loading };
        }
        return finish();
    };
    QueryData.prototype.fetchData = function () {
        if (this.options.skip)
            return false;
        var _a = this.options, children = _a.children, ssr = _a.ssr, displayName = _a.displayName, skip = _a.skip, onCompleted = _a.onCompleted, onError = _a.onError, partialRefetch = _a.partialRefetch, opts = tslib.__rest(_a, ["children", "ssr", "displayName", "skip", "onCompleted", "onError", "partialRefetch"]);
        var fetchPolicy = opts.fetchPolicy;
        if (ssr === false)
            return false;
        if (fetchPolicy === 'network-only' || fetchPolicy === 'cache-and-network') {
            fetchPolicy = 'cache-first';
        }
        var obs = this.refreshClient().client.watchQuery(tslib.__assign({}, opts, { fetchPolicy: fetchPolicy }));
        if (this.context && this.context.renderPromises) {
            this.context.renderPromises.registerSSRObservable(obs, this.options);
        }
        var result = this.currentObservable.query.getCurrentResult();
        return result.loading ? obs.result() : false;
    };
    QueryData.prototype.afterExecute = function () {
        this.isMounted = true;
        this.handleErrorOrCompleted();
        return this.unmount.bind(this);
    };
    QueryData.prototype.cleanup = function () {
        this.removeQuerySubscription();
        this.currentObservable.query = null;
        this.previousData.result = null;
    };
    QueryData.prototype.updateCurrentData = function () {
        if (this.isMounted) {
            this.forceUpdate();
        }
    };
    QueryData.prototype.prepareObservableQueryOptions = function () {
        this.verifyDocumentType(this.options.query, reactCommon.DocumentType.Query);
        var displayName = this.options.displayName || 'Query';
        return tslib.__assign({}, this.options, { displayName: displayName, context: this.options.context || {}, metadata: { reactComponent: { displayName: displayName } } });
    };
    QueryData.prototype.observableQueryFields = function (observable) {
        var fields = {
            variables: observable.variables,
            refetch: observable.refetch.bind(observable),
            fetchMore: observable.fetchMore.bind(observable),
            updateQuery: observable.updateQuery.bind(observable),
            startPolling: observable.startPolling.bind(observable),
            stopPolling: observable.stopPolling.bind(observable),
            subscribeToMore: observable.subscribeToMore.bind(observable)
        };
        return fields;
    };
    QueryData.prototype.initializeObservableQuery = function () {
        if (this.context && this.context.renderPromises) {
            this.currentObservable.query = this.context.renderPromises.getSSRObservable(this.options);
        }
        if (!this.currentObservable.query) {
            var observableQueryOptions = this.prepareObservableQueryOptions();
            this.previousData.observableQueryOptions = tslib.__assign({}, observableQueryOptions, { children: null });
            this.currentObservable.query = this.refreshClient().client.watchQuery(observableQueryOptions);
        }
    };
    QueryData.prototype.updateObservableQuery = function () {
        if (!this.currentObservable.query) {
            this.initializeObservableQuery();
        }
        var newObservableQueryOptions = tslib.__assign({}, this.prepareObservableQueryOptions(), { children: null });
        if (!isEqual(newObservableQueryOptions, this.previousData.observableQueryOptions)) {
            this.previousData.observableQueryOptions = newObservableQueryOptions;
            this.currentObservable
                .query.setOptions(newObservableQueryOptions)
                .catch(function () { return null; });
        }
    };
    QueryData.prototype.startQuerySubscription = function () {
        var _this = this;
        if (this.currentObservable.subscription)
            return;
        var obsQuery = this.currentObservable.query;
        this.currentObservable.subscription = obsQuery.subscribe({
            next: function (_a) {
                var loading = _a.loading, networkStatus = _a.networkStatus, data = _a.data;
                if (_this.previousData.result &&
                    _this.previousData.result.loading === loading &&
                    _this.previousData.result.networkStatus === networkStatus &&
                    isEqual(_this.previousData.result.data, data || {})) {
                    return;
                }
                _this.updateCurrentData();
            },
            error: function (error) {
                if (!_this.previousData.result ||
                    _this.previousData.result.networkStatus === apolloClient.NetworkStatus.refetch) {
                    _this.resubscribeToQuery();
                }
                if (!error.hasOwnProperty('graphQLErrors'))
                    throw error;
                _this.updateCurrentData();
            }
        });
    };
    QueryData.prototype.resubscribeToQuery = function () {
        this.removeQuerySubscription();
        var lastError = this.currentObservable.query.getLastError();
        var lastResult = this.currentObservable.query.getLastResult();
        this.currentObservable.query.resetLastResults();
        this.startQuerySubscription();
        Object.assign(this.currentObservable.query, {
            lastError: lastError,
            lastResult: lastResult
        });
    };
    QueryData.prototype.getQueryResult = function () {
        var result = {
            data: Object.create(null)
        };
        Object.assign(result, this.observableQueryFields(this.currentObservable.query));
        if (this.options.skip) {
            result = tslib.__assign({}, result, { data: undefined, error: undefined, loading: false });
        }
        else {
            var currentResult = this.currentObservable.query.getCurrentResult();
            var loading = currentResult.loading, partial = currentResult.partial, networkStatus = currentResult.networkStatus, errors = currentResult.errors;
            var error = currentResult.error, data = currentResult.data;
            data = data || Object.create(null);
            if (errors && errors.length > 0) {
                error = new apolloClient.ApolloError({ graphQLErrors: errors });
            }
            Object.assign(result, { loading: loading, networkStatus: networkStatus, error: error });
            if (loading) {
                var previousData = this.previousData.result
                    ? this.previousData.result.data
                    : {};
                Object.assign(result.data, previousData, data);
            }
            else if (error) {
                Object.assign(result, {
                    data: (this.currentObservable.query.getLastResult() || {})
                        .data
                });
            }
            else {
                var fetchPolicy = this.currentObservable.query.options.fetchPolicy;
                var partialRefetch = this.options.partialRefetch;
                if (partialRefetch &&
                    Object.keys(data).length === 0 &&
                    partial &&
                    fetchPolicy !== 'cache-only') {
                    Object.assign(result, {
                        loading: true,
                        networkStatus: apolloClient.NetworkStatus.loading
                    });
                    result.refetch();
                    return result;
                }
                Object.assign(result.data, data);
            }
        }
        result.client = this.client;
        this.previousData.loading =
            (this.previousData.result && this.previousData.result.loading) || false;
        this.previousData.result = result;
        return result;
    };
    QueryData.prototype.handleErrorOrCompleted = function () {
        var _a = this.currentObservable.query.getCurrentResult(), data = _a.data, loading = _a.loading, error = _a.error;
        if (!loading) {
            var _b = this.options, query = _b.query, variables = _b.variables, onCompleted = _b.onCompleted, onError = _b.onError;
            if (this.previousOptions &&
                isEqual(this.previousOptions.query, query) &&
                isEqual(this.previousOptions.variables, variables) &&
                !this.previousData.loading) {
                return;
            }
            if (onCompleted && !error) {
                onCompleted(data);
            }
            else if (onError && error) {
                onError(error);
            }
        }
    };
    QueryData.prototype.removeQuerySubscription = function () {
        if (this.currentObservable.subscription) {
            this.currentObservable.subscription.unsubscribe();
            delete this.currentObservable.subscription;
        }
    };
    return QueryData;
}(OperationData));

function useQuery(query, options) {
    var context = React.useContext(reactCommon.getApolloContext());
    var _a = React.useReducer(function (x) { return x + 1; }, 0), _ignored = _a[0], forceUpdate = _a[1];
    var updatedOptions = options ? tslib.__assign({}, options, { query: query }) : { query: query };
    var queryDataRef = React.useRef();
    function getQueryDataRef() {
        if (!queryDataRef.current) {
            queryDataRef.current = new QueryData({
                options: updatedOptions,
                context: context,
                forceUpdate: forceUpdate
            });
        }
        return queryDataRef.current;
    }
    var queryData = getQueryDataRef();
    queryData.options = updatedOptions;
    queryData.context = context;
    React.useEffect(function () {
        return queryData.afterExecute();
    });
    return queryData.execute();
}

var MutationData = (function (_super) {
    tslib.__extends(MutationData, _super);
    function MutationData(_a) {
        var options = _a.options, context = _a.context, result = _a.result, setResult = _a.setResult;
        var _this = _super.call(this, options, context) || this;
        _this.verifyDocumentType(options.mutation, reactCommon.DocumentType.Mutation);
        _this.result = result;
        _this.setResult = setResult;
        _this.mostRecentMutationId = 0;
        return _this;
    }
    MutationData.prototype.execute = function (result) {
        var _this = this;
        this.verifyDocumentType(this.options.mutation, reactCommon.DocumentType.Mutation);
        var runMutation = function (options) { return _this.runMutation(options); };
        return [runMutation, result];
    };
    MutationData.prototype.afterExecute = function () {
        this.isMounted = true;
        return this.unmount.bind(this);
    };
    MutationData.prototype.cleanup = function () {
    };
    MutationData.prototype.runMutation = function (mutationFunctionOptions) {
        var _this = this;
        if (mutationFunctionOptions === void 0) { mutationFunctionOptions = {}; }
        this.onMutationStart();
        var mutationId = this.generateNewMutationId();
        return this.mutate(mutationFunctionOptions)
            .then(function (response) {
            _this.onMutationCompleted(response, mutationId);
            return response;
        })
            .catch(function (error) {
            _this.onMutationError(error, mutationId);
            if (!_this.options.onError)
                throw error;
        });
    };
    MutationData.prototype.mutate = function (mutationFunctionOptions) {
        var _a = this.options, mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, update = _a.update, _b = _a.context, mutationContext = _b === void 0 ? {} : _b, _c = _a.awaitRefetchQueries, awaitRefetchQueries = _c === void 0 ? false : _c, fetchPolicy = _a.fetchPolicy;
        var mutateOptions = tslib.__assign({}, mutationFunctionOptions);
        var refetchQueries = mutateOptions.refetchQueries || this.options.refetchQueries;
        var mutateVariables = Object.assign({}, variables, mutateOptions.variables);
        delete mutateOptions.variables;
        return this.refreshClient().client.mutate(tslib.__assign({ mutation: mutation,
            optimisticResponse: optimisticResponse,
            refetchQueries: refetchQueries,
            awaitRefetchQueries: awaitRefetchQueries,
            update: update, context: mutationContext, fetchPolicy: fetchPolicy, variables: mutateVariables }, mutateOptions));
    };
    MutationData.prototype.onMutationStart = function () {
        if (!this.result.loading && !this.options.ignoreResults) {
            this.updateResult({
                loading: true,
                error: undefined,
                data: undefined,
                called: true
            });
        }
    };
    MutationData.prototype.onMutationCompleted = function (response, mutationId) {
        var _a = this.options, onCompleted = _a.onCompleted, ignoreResults = _a.ignoreResults;
        var data = response.data, errors = response.errors;
        var error = errors && errors.length > 0
            ? new apolloClient.ApolloError({ graphQLErrors: errors })
            : undefined;
        var callOncomplete = function () {
            return onCompleted ? onCompleted(data) : null;
        };
        if (this.isMostRecentMutation(mutationId) && !ignoreResults) {
            this.updateResult({
                called: true,
                loading: false,
                data: data,
                error: error
            });
        }
        callOncomplete();
    };
    MutationData.prototype.onMutationError = function (error, mutationId) {
        var onError = this.options.onError;
        var callOnError = function () { return (onError ? onError(error) : null); };
        if (this.isMostRecentMutation(mutationId)) {
            this.updateResult({
                loading: false,
                error: error,
                data: undefined,
                called: true
            });
        }
        callOnError();
    };
    MutationData.prototype.generateNewMutationId = function () {
        this.mostRecentMutationId += 1;
        return this.mostRecentMutationId;
    };
    MutationData.prototype.isMostRecentMutation = function (mutationId) {
        return this.mostRecentMutationId === mutationId;
    };
    MutationData.prototype.updateResult = function (result) {
        if (this.isMounted &&
            (!this.previousResult || !isEqual(this.previousResult, result))) {
            this.setResult(result);
            this.previousResult = result;
        }
    };
    return MutationData;
}(OperationData));

function useMutation(mutation, options) {
    var context = React.useContext(reactCommon.getApolloContext());
    var _a = React.useState({ called: false, loading: false }), result = _a[0], setResult = _a[1];
    var updatedOptions = options ? tslib.__assign({}, options, { mutation: mutation }) : { mutation: mutation };
    var mutationDataRef = React.useRef();
    function getMutationDataRef() {
        if (!mutationDataRef.current) {
            mutationDataRef.current = new MutationData({
                options: updatedOptions,
                context: context,
                result: result,
                setResult: setResult
            });
        }
        return mutationDataRef.current;
    }
    var mutationData = getMutationDataRef();
    mutationData.options = updatedOptions;
    mutationData.context = context;
    React.useEffect(function () {
        return mutationData.afterExecute();
    });
    return mutationData.execute(result);
}

var SubscriptionData = (function (_super) {
    tslib.__extends(SubscriptionData, _super);
    function SubscriptionData(_a) {
        var options = _a.options, context = _a.context, setResult = _a.setResult;
        var _this = _super.call(this, options, context) || this;
        _this.currentObservable = {};
        _this.setResult = setResult;
        _this.initialize(options);
        return _this;
    }
    SubscriptionData.prototype.execute = function (result) {
        var currentResult = result;
        if (this.refreshClient().isNew) {
            currentResult = this.getLoadingResult();
        }
        var shouldResubscribe = this.options.shouldResubscribe;
        if (typeof shouldResubscribe === 'function') {
            shouldResubscribe = !!shouldResubscribe(this.options);
        }
        if (shouldResubscribe !== false &&
            this.previousOptions &&
            Object.keys(this.previousOptions).length > 0 &&
            (!isEqual(this.previousOptions.variables, this.options.variables) ||
                this.previousOptions.subscription !== this.options.subscription)) {
            this.endSubscription();
            delete this.currentObservable.query;
            currentResult = this.getLoadingResult();
        }
        this.initialize(this.options);
        this.startSubscription();
        this.previousOptions = this.options;
        return tslib.__assign({}, currentResult, { variables: this.options.variables });
    };
    SubscriptionData.prototype.afterExecute = function () {
        this.isMounted = true;
        return this.unmount.bind(this);
    };
    SubscriptionData.prototype.cleanup = function () {
        this.endSubscription();
        delete this.currentObservable.query;
    };
    SubscriptionData.prototype.initialize = function (options) {
        if (this.currentObservable.query)
            return;
        this.currentObservable.query = this.refreshClient().client.subscribe({
            query: options.subscription,
            variables: options.variables,
            fetchPolicy: options.fetchPolicy
        });
    };
    SubscriptionData.prototype.startSubscription = function () {
        if (this.currentObservable.subscription)
            return;
        this.currentObservable.subscription = this.currentObservable.query.subscribe({
            next: this.updateCurrentData.bind(this),
            error: this.updateError.bind(this),
            complete: this.completeSubscription.bind(this)
        });
    };
    SubscriptionData.prototype.getLoadingResult = function () {
        return {
            loading: true,
            error: undefined,
            data: undefined
        };
    };
    SubscriptionData.prototype.updateResult = function (result) {
        if (this.isMounted) {
            this.setResult(result);
        }
    };
    SubscriptionData.prototype.updateCurrentData = function (result) {
        var onSubscriptionData = this.options.onSubscriptionData;
        if (onSubscriptionData) {
            onSubscriptionData({
                client: this.refreshClient().client,
                subscriptionData: result
            });
        }
        this.updateResult({
            data: result.data,
            loading: false,
            error: undefined
        });
    };
    SubscriptionData.prototype.updateError = function (error) {
        this.updateResult({
            error: error,
            loading: false
        });
    };
    SubscriptionData.prototype.completeSubscription = function () {
        var onSubscriptionComplete = this.options.onSubscriptionComplete;
        if (onSubscriptionComplete)
            onSubscriptionComplete();
        this.endSubscription();
    };
    SubscriptionData.prototype.endSubscription = function () {
        if (this.currentObservable.subscription) {
            this.currentObservable.subscription.unsubscribe();
            delete this.currentObservable.subscription;
        }
    };
    return SubscriptionData;
}(OperationData));

function useSubscription(subscription, options) {
    var context = React.useContext(reactCommon.getApolloContext());
    var _a = React.useState({
        loading: true,
        error: undefined,
        data: undefined
    }), result = _a[0], setResult = _a[1];
    var updatedOptions = options
        ? tslib.__assign({}, options, { subscription: subscription }) : { subscription: subscription };
    var subscriptionDataRef = React.useRef();
    function getSubscriptionDataRef() {
        if (!subscriptionDataRef.current) {
            subscriptionDataRef.current = new SubscriptionData({
                options: updatedOptions,
                context: context,
                setResult: setResult
            });
        }
        return subscriptionDataRef.current;
    }
    var subscriptionData = getSubscriptionDataRef();
    subscriptionData.options = updatedOptions;
    subscriptionData.context = context;
    React.useEffect(function () {
        return subscriptionData.afterExecute();
    });
    return subscriptionData.execute(result);
}

function useApolloClient() {
    var client = React__default.useContext(reactCommon.getApolloContext()).client;
    process.env.NODE_ENV === "production" ? tsInvariant.invariant(client) : tsInvariant.invariant(client, 'No Apollo Client instance can be found. Please ensure that you ' +
        'have called `ApolloProvider` higher up in your tree.');
    return client;
}

function makeDefaultQueryInfo() {
    return {
        seen: false,
        observable: null
    };
}
var RenderPromises = (function () {
    function RenderPromises() {
        this.queryPromises = new Map();
        this.queryInfoTrie = new Map();
    }
    RenderPromises.prototype.registerSSRObservable = function (observable, props) {
        this.lookupQueryInfo(props).observable = observable;
    };
    RenderPromises.prototype.getSSRObservable = function (props) {
        return this.lookupQueryInfo(props).observable;
    };
    RenderPromises.prototype.addQueryPromise = function (queryInstance, finish) {
        var info = this.lookupQueryInfo(queryInstance.options);
        if (!info.seen) {
            this.queryPromises.set(queryInstance.options, new Promise(function (resolve) {
                resolve(queryInstance.fetchData());
            }));
            return null;
        }
        return finish();
    };
    RenderPromises.prototype.hasPromises = function () {
        return this.queryPromises.size > 0;
    };
    RenderPromises.prototype.consumeAndAwaitPromises = function () {
        var _this = this;
        var promises = [];
        this.queryPromises.forEach(function (promise, queryInstance) {
            _this.lookupQueryInfo(queryInstance).seen = true;
            promises.push(promise);
        });
        this.queryPromises.clear();
        return Promise.all(promises);
    };
    RenderPromises.prototype.lookupQueryInfo = function (props) {
        var queryInfoTrie = this.queryInfoTrie;
        var query = props.query, variables = props.variables;
        var varMap = queryInfoTrie.get(query) || new Map();
        if (!queryInfoTrie.has(query))
            queryInfoTrie.set(query, varMap);
        var variablesString = JSON.stringify(variables);
        var info = varMap.get(variablesString) || makeDefaultQueryInfo();
        if (!varMap.has(variablesString))
            varMap.set(variablesString, info);
        return info;
    };
    return RenderPromises;
}());
function getDataFromTree(tree, context) {
    if (context === void 0) { context = {}; }
    return getMarkupFromTree({
        tree: tree,
        context: context,
        renderFunction: require('react-dom/server').renderToStaticMarkup
    });
}
function getMarkupFromTree(_a) {
    var tree = _a.tree, _b = _a.context, context = _b === void 0 ? {} : _b, _c = _a.renderFunction, renderFunction = _c === void 0 ? require('react-dom/server').renderToStaticMarkup : _c;
    var renderPromises = new RenderPromises();
    function process() {
        var ApolloContext = reactCommon.getApolloContext();
        var html = renderFunction(React__default.createElement(ApolloContext.Provider, { value: tslib.__assign({}, context, { renderPromises: renderPromises }) }, tree));
        return renderPromises.hasPromises()
            ? renderPromises.consumeAndAwaitPromises().then(process)
            : html;
    }
    return Promise.resolve().then(process);
}

function renderToStringWithData(component) {
    return getMarkupFromTree({
        tree: component,
        renderFunction: require('react-dom/server').renderToString
    });
}

Object.defineProperty(exports, 'ApolloConsumer', {
    enumerable: true,
    get: function () {
        return reactCommon.ApolloConsumer;
    }
});
Object.defineProperty(exports, 'ApolloProvider', {
    enumerable: true,
    get: function () {
        return reactCommon.ApolloProvider;
    }
});
Object.defineProperty(exports, 'getApolloContext', {
    enumerable: true,
    get: function () {
        return reactCommon.getApolloContext;
    }
});
Object.defineProperty(exports, 'resetApolloContext', {
    enumerable: true,
    get: function () {
        return reactCommon.resetApolloContext;
    }
});
exports.getDataFromTree = getDataFromTree;
exports.getMarkupFromTree = getMarkupFromTree;
exports.renderToStringWithData = renderToStringWithData;
exports.useApolloClient = useApolloClient;
exports.useMutation = useMutation;
exports.useQuery = useQuery;
exports.useSubscription = useSubscription;
